package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"strings"

	"github.com/quasilyte/gogrep"
	"github.com/quasilyte/gogrep/filters"
	"github.com/quasilyte/perf-heatmap/heatmap"
)

type worker struct {
	id int

	countMode bool

	workDir string
	heatmap *heatmap.Index

	filterHints filterHints
	filterInfo  *filters.Info
	filterExpr  *filters.Expr

	m           *gogrep.Pattern
	gogrepState gogrep.MatcherState
	fset        *token.FileSet

	matches []match

	errors []string

	data     []byte
	filename string
	n        int
}

func (w *worker) grepFile(filename string) (int, error) {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return 0, fmt.Errorf("read file: %v", err)
	}

	w.fset = token.NewFileSet()
	root, err := w.parseFile(w.fset, filename, data)
	if err != nil {
		return 0, err
	}

	if w.filterHints.autogenCond != bool3unset {
		if !w.filterHints.autogenCond.Eq(isAutogenFile(root)) {
			return 0, nil
		}
	}

	w.data = data
	w.filename = filename
	w.n = 0
	ast.Inspect(root, w.Visit)
	return w.n, nil
}

func (w *worker) parseFile(fset *token.FileSet, filename string, data []byte) (*ast.File, error) {
	needComments := false
	if w.filterHints.autogenCond != bool3unset {
		needComments = true
	}
	parserFlags := parser.Mode(0)
	if needComments {
		parserFlags |= parser.ParseComments
	}
	f, err := parser.ParseFile(fset, filename, data, parserFlags)
	if err != nil {
		return nil, err
	}
	return f, nil
}

func (w *worker) Visit(n ast.Node) bool {
	w.m.MatchNode(&w.gogrepState, n, func(data gogrep.MatchData) {
		accept := w.filterExpr.Op == filters.OpNop ||
			applyFilter(filterContext{w: w, m: data}, w.filterExpr, data.Node)
		if !accept {
			return
		}

		w.n++

		if w.countMode {
			return
		}

		start := w.fset.Position(data.Node.Pos())
		end := w.fset.Position(data.Node.End())
		m := match{
			filename: w.filename,
			line:     start.Line,
			startPos: start.Offset,
			endPos:   end.Offset,
		}
		w.initMatchText(&m, start.Offset, end.Offset)
		w.matches = append(w.matches, m)
	})

	return true
}

func (w *worker) initMatchText(m *match, startPos, endPos int) {
	isNewline := func(b byte) bool {
		return b == '\n' || b == '\r'
	}

	// Try to expand the match pos range in a way that it includes the
	// For example, if we have `if foo {` source line and `foo` matches,
	// we would want to record the `if foo {` string as a matching line.
	start := startPos
	for start > 0 {
		if isNewline(w.data[start]) {
			if start != startPos {
				start++
			}
			break
		}
		start--
	}
	end := endPos
	for end < len(w.data) {
		if isNewline(w.data[end]) {
			break
		}
		end++
	}

	m.text = string(w.data[start:end])
	m.matchStartOffset = startPos - start
	m.matchLength = endPos - startPos
}

func isAutogenFile(f *ast.File) bool {
	for _, comment := range f.Comments {
		if isAutogenComment(comment) {
			return true
		}
	}
	return false
}

func isAutogenComment(comment *ast.CommentGroup) bool {
	generated := false
	doNotEdit := false
	for _, c := range comment.List {
		s := strings.ToLower(c.Text)
		if !generated {
			generated = strings.Contains(s, " code generated ") ||
				strings.Contains(s, " generated by ")
		}
		if !doNotEdit {
			doNotEdit = strings.Contains(s, "do not edit") ||
				strings.Contains(s, "don't edit")
		}
		if generated && doNotEdit {
			return true
		}
	}
	return false
}
